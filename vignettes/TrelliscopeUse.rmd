---
title: "Testing Stats Plot functions"
author: "RR"
date: "5/9/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = F, warning = F, message = F)
library(dplyr)
library(ggplot2)
library(patchwork)
library(plotly)
library(pmartR)
library(purrr)
library(reshape2)
library(tidyverse)
library(trelliscopejs)
library(kableExtra)
library(knitr)
library(pmartRdata)

```

# Overview of pmartR

## The pmartR package is designed to simplify data cleaning and statistical tests for lipid, metabolomic, and proteomic datasets. After creating a data object of the appropriate class using as.lipidData(), as.metabData(), as.proData(), as.pepData, or as.isobaricpepData(), built in functions automate log transformation, NA result handling, designating samples in experimental groups, outlier detection, custom or statistical test filtering, custom or best-result subsetting and normalization, and mapped peptide "rollup" for generating protein data. After cleaning, the imd_anova() function can apply an independence of missing data (IMD) test (qualitative), appropriate analysis of varience (ANOVA) test (quantitative), or both.

## pMartR provides effective visualizations of each step in the process with built in plotting attributes of data objects for overall trends and summary statistics (utilized via plot() and summary()). Seperate plotting functions can also visualize overall similarity of data points (Probabilistic PCA) and missing data point statistics.

## Visualizing raw data points, ANOVA, or IMD tests across thousands of samples can be tedious; pmartR has a function for veiwing data and statistical results through the package 'trelliscopejs'. Below are examples and explanations of pmartR trelliscope visualizations on test datasets included in the package 'pmartRdata'.

# Data loading and pre-processing

## The package 'pmartRdata' contains sample data for use in as.lipidData(), as.metabData(), as.proData(), as.pepData, or as.isobaricpepData(). All objects require the use of e_data experimental result dataset and f_data experimental grouping dataset with an optional e_meta dataset for metadata.

```{r load pmartR data objects}
x <- data(package = "pmartRdata")
data(list = x$results[,3]) 
rm(x)
```

## Examples of generating data object. Note: e_data, f_data, and e_meta should be formatted appropriately.

``` {r example data object creation, eval = FALSE}

as.lipidData(e_data = lipid_edata, f_data = lipid_fdata, edata_cname = "LipidCommonName", fdata_cname = "Sample_Name", check.names = FALSE)

as.metabData(e_data = metab_edata, f_data = metab_fdata, edata_cname = "Metabolite", fdata_cname = "SampleID", check.names = FALSE)

as.proData(e_data = pro_edata, f_data = pro_fdata, edata_cname = "Reference", fdata_cname = "SampleID", check.names = FALSE, data_scale = "log2") #  norm_data = TRUE, norm_method = 'median_center' for object

as.pepData(e_data = pep_edata, e_meta = pep_emeta, f_data = pep_fdata, edata_cname = "Mass_Tag_ID", fdata_cname = "SampleID", emeta_cname = "Protein", check.names = FALSE)

# Pepdata with technical replicates
as.pepData(e_data = techrep_edata, f_data = techrep_fdata, edata_cname = "Mass_Tag_ID", fdata_cname = "RunID", techrep_cname = "TECH_REP", data_scale = "log2") # possibly unclear in help; combine tech_reps

# Option 1 
as.isobaricpepData(e_data = isobaric_edata, e_meta = isobaric_emeta, f_data = isobaric_fdata, edata_cname = "Peptide", fdata_cname = "Sample", emeta_cname = "Protein", channel_cname = "iTRAQ.Channel", exp_cname = "Set", refpool_channel = "116")

# Option 2
as.isobaricpepData(e_data = isobaric_edata, e_meta = isobaric_emeta, f_data = isobaric_fdata, edata_cname = "Peptide", fdata_cname = "Sample", emeta_cname = "Protein", exp_cname = "Set", refpool_cname = "Reference", refpool_notation = "Yes")

```

## The data objects are also avalaible as-is from the 'pmartRdata' package, which we will use here.

```{r process data, eval = FALSE}

## Identical to above example data objects with the exceptions of: ##
# ALL except techrep: Attribute $techrep_cname = NULL
# proData object: Attributes norm_data = TRUE, norm_method = 'median_center' for object
# isobaric object (created with option 2): data_info.datanorm = "FALSE", data_info.isobaric_norm = "FALSE", meta_info = "FALSE" (emeta is present though?)
# isobaric data: data_info.norm_info.is_normalized = "FALSE", data_info.num_emeta = "500", meta_info = "TRUE", isobaric_info.norm_info.is_normalized = "FALSE"

head(isobaric_object)
head(lipid_object)
head(metab_object)
head(pep_object)
head(pro_object)
head(techrep_pep_object)

attr(techrep_pep_object, "check.names") <- FALSE
# techrep_pep_object$e_data
# #check.names = FALSE for this
# #Put it on github for pmartrdata
# attr(techrep_pep_object, "check.names") <- FALSE

```

## We can visualize the spread of these data objects directly with plot() and summary statistics with summary(). This hold true after NA replacement, log transforming, filtering, and normalizing as well.

```{r}

objects <- list(isobaric_object, lipid_object, metab_object, pep_object, pro_object, techrep_pep_object)
#lapply(objects, plot)
#lapply(objects, summary)

#techrep breaks edata_replace
objects[-6] <- objects[-6] %>% map(function(dataobs) edata_replace(dataobs, 0, NA))

# objects[6][[1]]$e_data
# objects[6][[1]]$f_data


#Avoid error during transform
adjustedobs <- unlist(map(
  map(objects, attributes), 
  function(objatts) objatts$data_info$data_scale == "log2")
  )

objects[!adjustedobs] <- objects[!adjustedobs] %>% map(function(dataobject) edata_transform(dataobject, "log2"))
#lapply(objects, plot)
#lapply(objects, summary)

```

# Data specific functions

## Group designation, filters, and normalization are dependent on data content and should be selcted for specifically:

```{r setting groups}

# Individualized groupings, main effects must be specified (up to 2). 
# Multiple factors set to column 2 in group_DF (named "Group")

objects[1][[1]] <- group_designation(objects[1][[1]], c('Group', 'Set'))       # isobaric_object
objects[2][[1]] <- group_designation(objects[2][[1]], 'Condition')             # lipid_object
objects[3][[1]] <- group_designation(objects[3][[1]], 'Condition')             # metab_object
objects[4][[1]] <- group_designation(objects[4][[1]], 'Condition')             # pep_object
objects[5][[1]] <- group_designation(objects[5][[1]], 'Condition')             # pro_object
objects[6][[1]] <- group_designation(objects[6][[1]], c('FACTOR', 'DILUTION')) # techrep_pep_object

```

## Filters and outlier detection

## Note: Filtering will throw an error if the same filter has already been applied to an object. 

### Peptides
```{r setting groups}

# ONLY for pep objects with e_meta (techrep_pep_object has no emeta)

x <- proteomics_filter(objects[4][[1]]) # pep_object
# summary(x)
# plot(x)
objects[4][[1]] <- applyFilt(x, objects[4][[1]])

#Note that multiple proteins map to the same peptide in the isobaric object
x <- proteomics_filter(objects[1][[1]]) # isobaric_object
summary(x)
plot(x)

objects[1][[1]] <- applyFilt( x, objects[1][[1]], degen_peps = TRUE) #filters out degen peps
x <- proteomics_filter(objects[1][[1]])
summary(x)
plot(x)

rm(x)
```

### All omicsData

```{r}

## Filter pipeline with initial settings matching the default settings for each function
filterpipe <- function(omicsData, min_num = 1, cv_threshold = 150, 
                       min_nonmiss_gtest = NULL, min_nonmiss_anova = NULL){
  molfilter <- molecule_filter(omicsData) %>%
    applyFilt(omicsData, min_num = min_num)
  cvmolfilter <- cv_filter(molfilter) %>%
    applyFilt(molfilter, cv_threshold = cv_threshold)
  misscvmolfilter <- imdanova_filter(cvmolfilter) %>%
    applyFilt(cvmolfilter, min_nonmiss_gtest = min_nonmiss_gtest, 
              min_nonmiss_anova = min_nonmiss_anova)
  return(misscvmolfilter)
}

# Need at least 3 points for a g-test, however cannot compute if the minimum amount of samples in any given group is < 3 (or the selected min_nonmiss_gtest number). The isobaric_object only has 6 samples across 2 groups (four A and two B) which has been further divided into 1_A, 2_A, and 3_B when "Set" was used as part of the group_designation() function. G-test should not be used.

# Tip: Use summary to check if filter has processed data and number of samples in each group.

# Metab, lipid, pro summary group count not showing up?
# due to use of levels() in calls for metab, lipid, and pro, but unique() for peps

# Assign as filter objects
objects[1][[1]] <- filterpipe(objects[1][[1]], cv_threshold = 120, min_num = 3,
                              min_nonmiss_gtest = NULL, min_nonmiss_anova = 2) # isobaric_object
objects[2][[1]] <- filterpipe(objects[2][[1]], cv_threshold = 120, min_num = 3,
                              min_nonmiss_gtest = 3, min_nonmiss_anova = 2)    # lipid_object
objects[3][[1]] <- filterpipe(objects[3][[1]], cv_threshold = 120, min_num = 3,
                              min_nonmiss_gtest = 3, min_nonmiss_anova = 2)    # metab_object
objects[4][[1]] <- filterpipe(objects[4][[1]], cv_threshold = 120, min_num = 3,
                              min_nonmiss_gtest = 3)    # pep_object
objects[5][[1]] <- filterpipe(objects[5][[1]], cv_threshold = 120, min_num = 3,
                              min_nonmiss_gtest = 3, min_nonmiss_anova = 2)    # pro_object
objects[6][[1]] <- filterpipe(objects[6][[1]], cv_threshold = 120, min_num = 3,
                              min_nonmiss_gtest = 3, min_nonmiss_anova = 2)    # techrep_pep_object

```


## Outlier Detection and Removal

```{r}

## Set pvalue threshold appropriately before use. Default filter metrics used. (See ?rmd_filter())
## Prints graphs and summary and outputs a list of outlier samples
detectOutliers <- function(omicsData, pvalue_threshold = 1e-04){
  print(class(omicsData))
  outliers <- rmd_filter(omicsData)
  sumout <- summary(outliers, pvalue_threshold = pvalue_threshold)
  print(sumout)
  print(plot(outliers, pvalue_threshold = pvalue_threshold))
  for (sample in sumout$filtered_samples){
    if(sample != "NULL"){
      print(plot(outliers, sampleID = sample))
    }
  }
  return(sumout$filtered_samples)
}


# detectOutliers(objects[1][[1]])     # isobaric_object
# 
# objects[1][[1]]
# 
# rmd_filter(objects[1][[1]])  ### Breaks with isobaric??

#Questionable is a list of outliers
questionable <- map(objects[2:length(objects)], detectOutliers)
questionable

#Removes outliers identified. Modify list for conserving specific outliers.
for (n in 2:length(objects)){
  filt <- custom_filter(objects[n][[1]], 
                        f_data_remove = questionable[(n-1)][[1]])
  objects[n][[1]] <- applyFilt(filt, objects[n][[1]])
}

```

## Normalization

```{r}


norm_objects  <- map(objects, function(omicsData) {
  normalize_global(omicsData, subset_fn = "all", norm_fn = "median", apply_norm = T, backtransform = T)
}
)

##Normalize global add an X for tech reps edata??
## Messes up normalization
##normalize_global(objects[6][[1]], subset_fn = "all", norm_fn = "median", apply_norm = T, backtransform = T)

colnames(norm_objects[6][[1]]$e_data) <- c("Mass_Tag_ID", attributes(norm_objects[6][[1]])$group_DF$RunID)

norm_stats <- map(norm_objects, function (omicsData) {
  method <- attributes(omicsData)$filter$imdanovaFilt$filter_method
  if (length(method) == 1){
    imd_anova(omicsData, test_method = method)
  } else {
    imd_anova(omicsData, test_method = "combined")
  }
  }
  )

# Error in factor(groupData$Group, labels = 1:k, levels = unique(groupData$Group)) : 
#   invalid 'labels'; length 4 should be 1 or 0
#When colnames are not correct

#Work around for attributes

##?map2
for (item in 1:length(norm_objects)){
  attr(norm_stats[item][[1]], "cnames") <-  attr(norm_objects[item][[1]], "cnames")
}

```

```{r testing new functions}

isobar <- as.omicsPlotter(norm_objects[1][[1]], norm_stats[1][[1]])
lip <- as.omicsPlotter(norm_objects[2][[1]], norm_stats[2][[1]])
metab <- as.omicsPlotter(norm_objects[3][[1]], norm_stats[3][[1]])
pep <- as.omicsPlotter(norm_objects[4][[1]], norm_stats[4][[1]])
pro <- as.omicsPlotter(norm_objects[5][[1]], norm_stats[5][[1]])
techrep <- as.omicsPlotter(norm_objects[6][[1]], norm_stats[6][[1]])

plot_comps(isobar, y_range = 2) %>% 
  trelliscope(name = "isobar_test", nrow = 1, ncol = 2,
                  path = "../../../Displaytest", thumb = TRUE)

plot_comps(lip, y_range = 10, y_min = -2) %>% 
  trelliscope(name = "lipid_test", nrow = 1, ncol = 2,
                  path = "../../../Displaytest", thumb = TRUE)

plot_comps(metab, y_min = -2, y_max = 6) %>% 
  trelliscope(name = "metab_test", nrow = 1, ncol = 2,
                  path = "../../../Displaytest", thumb = TRUE)

plot_comps(pep, y_limits = "free")$panel %>% 
  trelliscope(name = "Pep_test", nrow = 1, ncol = 2,
                  path = "../../../Displaytest", thumb = TRUE)

plot_comps(pro, y_limits = "fixed") %>% 
  trelliscope(name = "Pro_test", nrow = 1, ncol = 2,
                  path = "../../../Displaytest", thumb = TRUE)

plot_comps(techrep, y_limits = "fixed", y_min = -3) %>% 
  trelliscope(name = "techrep_test", nrow = 1, ncol = 2,
                  path = "../../../Displaytest", thumb = TRUE)

plot_comps(techrep) %>% 
  trelliscope(name = "techrep_unfixed_test", nrow = 1, ncol = 2,
                  path = "../../../Displaytest", thumb = TRUE)

plot_comps(isobar)$panel
plot_comps(pep)$panel
plot_comps(pro)$panel ###??
x <- plot_comps(pep, panel_x_axis = "Flag", panel_variable = "Fold_change")$panel
attr(pep, "statistical_test")
x[2][[1]]$x$data
pro$summary_stats
x
```


```{r}

#################################
##Add protein cognostics for trelliscope

?as.omicsPlotter

## Stats for sorting ##
omicsData <- norm_objects[1][[1]]
omicsStats <- norm_stats[1][[1]]
omicsPlotter <- isobar

datacogs <- function(omicsPlotter, omicsData, omicsStats, p_val = 0.05, pep_pro_emeta = FALSE, pep_pro_cols = NULL, panel_variable = NULL){
  
  if (is.null(omicsPlotter)){
    omicsPlotter = omicsPlotter(omicsData, omicsStats)
  }
  
  ##Check for same between plotter, data, stats classes
  e_data <- omicsData$e_data[1:10,]
  f_data <- omicsData$f_data[1:10,]
  e_meta <- omicsData$e_meta[1:10,]
  stats <- omicsStats$Full_results[1:10,]
  
  # Assign unique ID, then panel variable

  uniqueID <- attributes(omicsPlotter)$cnames$edata_cname
  if(is.null(panel_variable) & !is.null(e_meta)){
    panel_variable <- attributes(omicsPlotter)$cnames$emeta_cname
  } else if (is.null(panel_variable)){
    panel_variable <- uniqueID
    }
  
  plotcomp <- plot_comps(omicsPlotter)
  
    addstatcogs <- merge(omicsStats, omicsData) %>% 
      nest(-panel_variable, -uniqueID, .key = "Original stats/values")
  plotcomp2 <- merge(plotcomp, addstatcogs)
  
  omicsStats <- NULL
  # %>%
  trelliscope(name = "isobar_test2", nrow = 1, ncol = 2,
                  path = "../../../Displaytest", thumb = TRUE)
  
  return(addstatcogs)
}

datacogs(plot_comps(isobar), 
         norm_objects[1][[1]]$e_data[1:10,],  
         norm_stats[1][[1]]$Full_results[1:10,])  


%>%
  trelliscope(name = "isobar_test", nrow = 1, ncol = 2,
                  path = "../../../Displaytest", thumb = TRUE)

```

```{r}

precogpro <- function(pro_stats, joinpep, uniqidpro, uniqidpep){
  
  prolist <- pro_stats[[uniqidpro]]
  pvalg <- data.frame(t(pro_stats[str_detect(names(pro_stats), "P_value_G")]))
  pvalt <- data.frame(t(pro_stats[str_detect(names(pro_stats), "P_value_T")]))
  colnames(pvalg) <- prolist
  colnames(pvalt) <- prolist
  
  Sig_G_p_value <- as.factor(prolist %in% names(
    select_if(pvalg, function(x) any(x < 0.05) && all(!is.na(x)))
    ))
  Sig_T_p_value <- as.factor(prolist %in% names(
    select_if(pvalt, function(x) any(x < 0.05) && all(!is.na(x)))
    ))
  n_Peptides <- data.frame(table(joinpep[[uniqidpro]]))
  colnames(n_Peptides) <- c(uniqidpro, "n_Peptides")
  
  degenpep <- joinpep[[uniqidpep]][which(
                                    duplicated(joinpep[[uniqidpep]])==TRUE)]
  Is_degenerate <- as.factor(joinpep[[uniqidpep]] %in% degenpep)
  
  n_degenerate_peps <- data.frame(table(
    joinpep[Is_degenerate == "TRUE",][[uniqidpro]]))
  
  colnames(n_degenerate_peps) <- c(uniqidpro, "n_degenerate_peps")
  
  propeps <- joinpep[,c(uniqidpep, uniqidpro)] %>% 
  nest(uniqidpep) %>% 
  mutate(data = unlist(map(data, function(peplist) {
    toString(unlist(lapply(peplist, as.character)), sep = ", ")
    }
    )))
  propeps <- data.frame(propeps[match(prolist, propeps$RazorProtein),])
  
  pronest <- pro_stats %>% nest(-uniqidpro) %>%
  mutate(
    Sig_G_p_value = cog(Sig_G_p_value, 
                        desc = "Boolean for significant G test p-values, where TRUE indicates that the p-value is < 0.05 and is grounds for rejecting the null hypothesis (independence of missing data)."),
    Sig_T_p_value = cog(Sig_T_p_value,
                        desc = "Boolean for significant T test p-values, where TRUE indicates that the p-value is < 0.05 and is grounds for rejecting the null hypothesis (no significant difference between groups)."),
    n_Peptides = cog(n_Peptides[prolist,]$n_Peptides, desc = "Number of peptides mapping to the selected protein"),
    n_degenerate = cog(n_degenerate_peps[prolist,]$n_degenerate_peps,
                        desc = "Number of degenerate peptides that map to the selected protein; degenerate peptides also match to other proteins."),
    Peptide_list = cog(propeps$data, desc = "Peptides that match to the selected protein"))
  
  return(pronest)
}
#################################
##Add peptide cognostics for trelliscope
precogpep <- function(joinpep, uniqidpep){
  
  peplist <- joinpep[[uniqidpep]]
  pvalg <- data.frame(t(joinpep[str_detect(names(joinpep), "P_value_G")]))
  pvalt <- data.frame(t(joinpep[str_detect(names(joinpep), "P_value_T")]))
  colnames(pvalg) <- substring(colnames(pvalg), 2)
  colnames(pvalt) <- substring(colnames(pvalt), 2)
  Sig_G_p_value <- as.factor(peplist %in% joinpep[[uniqidpep]][as.numeric(names(
    select_if(pvalg, function(x) any(x < 0.05) && all(!is.na(x)))
    ))])
  Sig_T_p_value <- as.factor(peplist %in% joinpep[[uniqidpep]][as.numeric(names(
    select_if(pvalt, function(x) any(x < 0.05) && all(!is.na(x)))
    ))])
  
  degenpep <- peplist[which(duplicated(peplist)==TRUE)]
  Is_degenerate <- as.factor(peplist %in% degenpep)
  
  nestedpep <-joinpep %>% nest(-uniqidpep, -uniqidpro) %>%
  mutate(
    Sig_G_p_value = cog(Sig_G_p_value, 
                        desc = "Boolean for significant G test p-values, where TRUE indicates that the p-value is < 0.05 and is grounds for rejecting the null hypothesis (independence of missing data)."),
    Sig_T_p_value = cog(Sig_T_p_value,
                        desc = "Boolean for significant T test p-values, where TRUE indicates that the p-value is < 0.05 and is grounds for rejecting the null hypothesis (no significant difference between groups)."),
    Is_degenerate = cog(Is_degenerate,
                        desc = "Boolean for degenerate peptides, where TRUE indicates that this peptide maps to multiple proteins."))
  return(nestedpep)
}


pepnest <- joinpep %>% precogpep(uniqidpep = uniqidpep)
pronest <- precogpro(pro_stats, joinpep, uniqidpro, uniqidpep)

```





